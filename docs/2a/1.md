

-----

#### **主题1：`sum` 求和模式的抽象意义 (Lec 2a)**

  * **核心问题**：将整数求和、平方和等问题中的通用求和模式抽象出来，其意义是什么？
  * **核心思想**：其本质是 **分离关注点 (Separation of Concerns)**，通过识别并命名一个 **通用计算模式 (General Computational Pattern)**，将“不变的算法骨架”与“变化的特定策略”解耦。
  * **要点总结**：
    1.  **识别“变”与“不变”**：“求和”的循环累加过程是**不变的**，“每一项是什么 (`term`)”以及“如何到下一项 (`next`)”是**变化的**。
    2.  **提升抽象层次**：将不变的模式封装为高阶函数 `sum`，让我们从思考繁琐的循环细节，提升到思考“项”和“下一步”的数学本质，极大地减轻了认知负担。
    3.  **创造领域特定语言 (DSL)**：通过 `sum`, `product` 等高阶函数的组合，我们实际上在构建一套用于处理序列问题的强大“语言”，使代码更具表达力。
    4.  **增强软件质量**：“求和”逻辑集中在一处，修复其bug或优化其性能，所有调用方均可受益，这使得系统更健壮、更易维护。

-----


#### **主题2：程序设计的“树形”心智模型**

  * **核心问题**：将复杂函数想象成一棵树，并以“**只有叶子节点是‘执行过程’，其他节点都偏向‘定义策略’**”为目标，这是否是一个好的设计哲学？

  * **核心思想**：**是的，这是一个极其优秀且深刻的软件设计哲学。** 它自然地引导我们构建出层次清晰、高内聚低耦合、易于测试和维护的系统。

  * **要点总结**：

    1.  **节点职责划分**：
          * **非叶子节点 (策略层)**：负责**组合与协调**，将工作委托给子节点。它们是声明式的，定义了“做什么 (What)”。
          * **叶子节点 (执行层)**：负责**具体工作**，执行原子操作（如IO、计算）。它们是命令式的，定义了“怎么做 (How)”。
    2.  **该模型的巨大优势**：
          * **可测试性**：叶子节点可独立进行单元测试，非叶子节点可通过模拟（Mocking）其子节点来进行集成测试。
          * **可替换性**：可以轻易替换一个叶子节点（如将数据库实现从MySQL换成PostgreSQL）而不影响上层策略。
          * **关注点分离**：不同开发者可以专注于树的不同层次，有效管理复杂度。
          * **自文档化**：树的结构本身就是一份高级的架构图。

    <!-- end list -->

    ```mermaid
    graph TD
        A["<b>根/中间节点 (策略层)</b><br/><i>定义做什么: 组合、协调</i>"] --> B["子节点 (策略/执行)"];
        A --> C["子节点 (策略/执行)"];
        subgraph " "
        direction LR
        B --> D["<b>叶子节点 (执行层)</b><br/><i>定义怎么做: IO, 计算等</i>"]
        end
    ```