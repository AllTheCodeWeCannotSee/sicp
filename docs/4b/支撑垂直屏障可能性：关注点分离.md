

### 支撑思想：间接（Indirection）与关注点分离（Separation of Concerns）

这种进步背后，是计算机科学中最核心、最强大的思想之一，通常被概括为：

**“计算机科学中的任何问题，都可以通过增加一个间接层来解决。”**
*(Any problem in computer science can be solved by another level of indirection.)*
-- David Wheeler

这个所谓的“间接层”（Indirection Layer），就是你所说的那个“操作表层”。我们之所以要费力气去构建这个层，是为了实现一个更根本的原则：**关注点分离 (Separation of Concerns, SoC)**。

让我们看看在SICP的例子中，我们分离了哪些“关注点”：

1.  **关注点A：通用接口的定义**
    * “我需要一个叫做`add`的操作，它能对系统里的数字进行加法。”
    * 这是`用户API层`的关注点。它应该保持简单和稳定。

2.  **关注点B：具体实现的逻辑**
    * “对于直角坐标，加法是(a+c, b+d)。”
    * “对于极坐标，加法要转换成直角坐标再计算...”
    * 这是`具体实现包`的关注点。每个包都应该只关心自己的内部逻辑。

3.  **关注点C：如何连接A和B**
    * “当用户调用`add`并传入两个直角坐标时，我应该选择`add-rectangular`这个实现。”
    * **这正是问题的核心！**

在没有“操作表层”的`cond`方案中，**关注点C被强行塞进了关注点A里面**。通用的`add`函数被迫承担了它不应该关心的“如何选择”的职责。这导致`add`函数变得臃肿、僵化，并且与所有具体实现都产生了紧密的耦合。

而“操作表层”的伟大之处在于，它**将关注点C完全独立了出来**，变成了一个专门负责“连接”或“调度”的独立层次。

* **现在的`add`函数（关注点A）**：职责极其单一，只负责向操作表发出请求。它变得“无知”而轻松。
* **现在的具体实现包（关注点B）**：职责也很单一，只负责实现自己的逻辑，并向操作表“注册”自己。它们也变得轻松。
* **现在的操作表层（关注点C）**：它的职责同样单一，就是维护一张映射表，并根据请求进行查询和分发。

通过增加这个间接层，我们把一个混乱、耦合的“大泥球”，拆分成了三个职责清晰、各自独立的“小零件”。这三个零件的内部复杂度都大大降低了，而且由于它们之间的接口（`put`/`get`）是如此简单和稳定，所以整个系统的灵活性和可维护性得到了质的飞跃。

