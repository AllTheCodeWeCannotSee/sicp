
**如果一个系统一开始没有为“可扩展性”而设计，那么在后续引入新功能时，重构（Refactoring）旧代码是不可避免的。**

“垂直屏障”或者说“数据导向编程”这套模式，并不能“凭空”出现。它是一种需要被**有意识地设计和构建**的架构。

让我们来完整地走一遍你描述的那个场景，这会非常清晰：

### 第一阶段：田园时代，系统里只有“有理数”

  * **代码状态**：在这个阶段，系统非常简单。我们根本不需要什么通用分发、类型标签。代码可能就是这样的：

    ```scheme
    ;; 构造函数
    (define (make-rat n d) (cons n d))
    ;; 选择器
    (define (numer x) (car x))
    (define (denom x) (cdr x))
    ;; 操作
    (define (add-rat x y)
      (make-rat (+ (* (numer x) (denom y))
                   (* (numer y) (denom x)))
                (* (denom x) (denom y))))

    ;; 用户API可能就是它自己
    (define add add-rat) 
    ```

  * **评价**：代码简单、直接、高效。对于“只处理有理数”这个需求来说，这是完美的。这里**没有**垂直屏障，甚至水平屏障都很薄弱。

### 第二阶段：危机来临，需要加入“复数”

  * **面临的问题**：现在，需求变更了，我们希望系统也能处理复数。

  * **糟糕的应对（打补丁）**：我们可能会去修改`add`函数：

    ```scheme
    (define (add x y)
      (if (is-rational? x)  ; 开始出现丑陋的if-else
          (add-rat x y)
          (add-complex x y))) ; 假设我们有了add-complex
    ```

    这个`if`就是技术债的开始。如果再加入多项式，这个`if`会变成一个更复杂的`cond`，代码会迅速腐化。

  * **明智的应对（架构升级）**：一位有经验的架构师（比如现在的你）会说：“停！我们的基本设计已经无法支撑未来的扩展了。我们现在需要引入一种更具扩展性的模式——数据导向编程。是时候进行**重构**了！”

### 第三阶段：重构，引入垂直屏障

现在，为了让系统能够优雅地接纳“复数”以及未来更多类型，我们必须动手改造旧的“有理数”代码。

**你的结论完全正确：有理数包就要修改。**

你需要对`有理数包`做如下几件事：

1.  **修改构造函数，让它“贴标签”**：
    ```scheme
    ;; 旧：(define (make-rat n d) (cons n d))
    ;; 新：
    (define (make-rat n d)
      (attach-tag 'rational (cons n d))) ; 必须加上这句！
    ```
2.  **修改选择器，让它能处理标签**：
    所有用到`car`和`cdr`的地方，现在都要先通过`contents`来剥掉标签层。
    ```scheme
    ;; 旧：(define (numer x) (car x))
    ;; 新：
    (define (numer x) (car (contents x)))
    ```
3.  **为操作进行“注册”**：
    你需要建立那个全局的操作表，然后把有理数的操作函数`put`进去。
    ```scheme
    (put 'add '(rational rational) add-rat)
    (put 'mul '(rational rational) mul-rat)
    ;; ... etc
    ```

**看到了吗？为了迎接“复数”这个新成员，我们不得不让“有理数”这个老成员去“穿上带标签的新制服”，并“学会新的汇报流程（注册）”。**

-----

### 这背后的思想：开闭原则 (Open-Closed Principle)

你所洞察到的这一切，正是软件设计中著名的\*\*开闭原则（OCP）\*\*的体现。

  * **原则定义**：软件实体（类、模块、函数等）应该对于**扩展是开放的（Open for extension）**，但是对于**修改是关闭的（Closed for modification）**。

  * **你的例子**：

      * **第一阶段的系统**：它是**关闭**的。为了增加新功能（复数），你必须**修改**旧代码（`add`函数）。它违反了开闭原则。
      * **第三阶段重构后的系统**：它是**开放**的。在引入了垂直屏障（操作表层）之后，如果你想再增加“四元数”这个新类型，你只需要增加一个`quaternion`包，然后去注册它。你**不需要再修改**有理数包、复数包、或者`apply-generic`本身。系统现在遵守了开闭原则。

**结论就是：**

“垂直屏障”的魔力，并不是说你从一开始什么都不想，系统就能自动扩展。它的真正价值在于，它是一种**实现“开闭原则”的强大设计模式**。

你付出的代价是**一次性的设计/重构成本**（建立操作表层，并让所有旧模块去适配它），而你得到的回报是**未来无限扩展的极低成本**。

这就像盖房子：

  * 盖个小木屋，不需要打地基。
  * 但如果你想把木屋扩建成摩天大楼，你不能在木屋上直接加盖。你必须停下来，拆掉木屋，花大力气挖深坑，浇筑一个坚固的地基（这就是重构，引入垂直屏障）。
  * 一旦地基打好了，再往上加盖第2层、第10层、第100层（增加新类型），就变得系统化和简单了。