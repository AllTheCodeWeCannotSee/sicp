

  * **方法一**：遵循命令式思想，手动管理状态和时间（回溯）。
  * **方法二**：遵循SICP的声明式思想，用“无时间”的视角来描述解的结构。

-----

### 方法一：命令式思维 —— “时间旅行者”的回溯算法

这种方法是我们最直观的思路。我们创建一个棋盘，一步步地放棋子，如果走不通了，就退回来换一步，直到找到所有解。

**核心思想**：

  * 我们有一个**可变的、共享的**棋盘状态。
  * 我们用一个递归函数来模拟**时间的演进**（在棋盘上逐行放置皇后）。
  * 我们**手动处理**“回溯”（Backtracking）的逻辑。

<!-- end list -->

```javascript
/**
 * 命令式 N 皇后解法
 * @param {number} n 皇后的数量（和棋盘的尺寸）
 * @returns {number[][]} 所有解的数组，每个解是一个表示皇后列位置的数组
 */
function nQueensImperative(n) {
  // solutions 用于存储所有找到的解，是一个共享的变量
  const solutions = [];
  
  // positions[row] = col 表示在第 row 行的第 col 列放置了一个皇后。
  // 这是我们贯穿整个求解过程的、可变的“单一世界”状态。
  const positions = [];

  /**
   * 检查在 (row, col) 位置放置皇后是否安全
   * @param {number} row
   * @param {number} col
   */
  function isSafe(row, col) {
    // 遍历之前所有已经放置好的皇后 (从第0行到第row-1行)
    for (let prevRow = 0; prevRow < row; prevRow++) {
      const prevCol = positions[prevRow];
      
      // 检查是否在同一列
      if (prevCol === col) {
        return false;
      }
      // 检查是否在同一对角线
      // (行差的绝对值 === 列差的绝对值)
      if (Math.abs(row - prevRow) === Math.abs(col - prevCol)) {
        return false;
      }
    }
    return true;
  }

  /**
   * 递归函数，尝试在第 row 行放置皇后
   * 这个函数的核心是副作用：它会修改外部的 positions 和 solutions 数组。
   * @param {number} row 当前要处理的行号
   */
  function solve(row) {
    // === 时间前进的终点：基线条件 ===
    // 如果所有行都成功放置了皇后
    if (row === n) {
      // 找到了一个完整的解，将其“快照”存入 solutions
      // 必须用 .slice() 创建一个副本，否则后续的回溯会修改它
      solutions.push(positions.slice());
      return;
    }

    // === 时间的演进：尝试当前行的所有可能性 ===
    for (let col = 0; col < n; col++) {
      if (isSafe(row, col)) {
        // 1. 做出选择 (修改状态，放置皇后)
        positions[row] = col;
        
        // 2. 向前一步 (递归到下一行)
        solve(row + 1);
        
        // 3. 撤销选择 (回溯)
        // 在这个实现中，我们不需要显式地 "positions[row] = null"
        // 因为下一次 for 循环会自动覆盖 positions[row] 的值。
        // 但在逻辑上，这里就是回溯点，我们回到了过去，准备尝试下一个选择。
      }
    }
  }

  // 从第 0 行开始，启动整个时间演进过程
  solve(0);
  return solutions;
}

// --- 特点分析 ---
// 1. 核心是可变状态：有一个贯穿始终的 `positions` 数组被反复修改。
// 2. 充满时间感：`solve(row + 1)` 是“前进到未来”，循环中的下一个 `col` 是“在当前时间点尝试另一种可能”。
// 3. 手动管理过程：程序员的大脑需要模拟回溯的过程，思考状态如何被修改和恢复。

console.log("命令式解法 (8皇后):");
const imperativeSolutions = nQueensImperative(8);
console.log(`找到了 ${imperativeSolutions.length} 个解。`);
// console.log(imperativeSolutions); // 解太多，可以取消注释查看
```

-----

### 方法二：声明式思维 —— “数学家”的 timeless 解法

这种方法完全转换了视角。我们不关心寻找解的“过程”，而是直接用代码来**定义“一个解的结构是什么样”**。

**核心思想**：

  * 数据是**不可变的**。我们不修改解，而是从旧的解集合生成新的解集合。
  * 函数是**纯函数**。`solve(k)` 的结果只依赖于`k`，不受任何外部状态影响。
  * **递归**定义了“k皇后的解”与“k-1皇后的解”之间的数学关系。

<!-- end list -->

```javascript
/**
 * 声明式 N 皇后解法
 * @param {number} n 皇后的数量
 * @returns {number[][]} 所有解的数组
 */
function nQueensDeclarative(n) {

  /**
   * 检查一个新的皇后 (在 newRow, newCol) 是否与已有的部分解 safe
   * @param {object} newQueen - {row, col}
   * @param {number[]} partialSolution - 已有皇后的列位置数组
   */
  function isSafe(newQueen, partialSolution) {
    const newRow = newQueen.row;
    const newCol = newQueen.col;
    
    // 遍历部分解中的每一个皇后
    for (let prevRow = 0; prevRow < partialSolution.length; prevRow++) {
      const prevCol = partialSolution[prevRow];
      if (newCol === prevCol || Math.abs(newRow - prevRow) === Math.abs(newCol - prevCol)) {
        return false;
      }
    }
    return true;
  }

  /**
   * 递归函数，它的含义是：“返回所有合法的 k 皇后解的集合”
   * 这个函数是纯函数，没有副作用。
   * @param {number} k 要求解的皇后数量
   * @returns {number[][]} k皇后的所有解
   */
  function solve(k) {
    // === 递归的基石：0皇后的解 ===
    // 放置0个皇后的方法只有一种：什么都不放（一个空集）。
    // 返回 `[[]]` 表示“一个包含了一个空解的集合”。这是后续构造的基础。
    if (k === 0) {
      return [[]];
    }
    
    // === 递归的定义：k皇后的解，是基于 k-1 皇后的解生成的 ===
    
    // 1. 首先，获取所有 k-1 皇后的解
    const prevSolutions = solve(k - 1);
    
    // 2. 然后，我们“生成”并“筛选”出 k 皇后的解
    // 使用 reduce 来实现 flatMap 的效果，将所有新生成的解汇集到一个数组中
    return prevSolutions.reduce((newSolutions, sol) => {
      // 对于每一个 k-1 的解 (sol)，尝试在第 k 行加上一个新皇后
      const newRow = k - 1;
      for (let newCol = 0; newCol < n; newCol++) {
        // 如果新加的皇后是安全的...
        if (isSafe({ row: newRow, col: newCol }, sol)) {
          // ...就将它与旧的解组合，生成一个“全新”的 k 皇后解，并加入结果集。
          // 注意：这里是创建新数组 `[...sol, newCol]`，而不是修改旧的！
          newSolutions.push([...sol, newCol]);
        }
      }
      return newSolutions;
    }, []);
  }

  // 直接描述我们的最终目标：“我想要 n 皇后的所有解”
  return solve(n);
}


// --- 特点分析 ---
// 1. 不可变性：没有任何变量被修改。函数接收一个集合，返回一个全新的集合。
// 2. 无时间感：代码没有“前进”、“后退”的概念。它是在描述一种永恒的数学关系。
// 3. 组合与声明：代码通过组合 `solve`, `isSafe`, `reduce` 等纯粹的构建块，来声明一个解的结构。

console.log("\n声明式解法 (8皇后):");
const declarativeSolutions = nQueensDeclarative(8);
console.log(`找到了 ${declarativeSolutions.length} 个解。`);
// console.log(declarativeSolutions);
```

### 总结对比

| 对比维度 | 方法一 (命令式) | 方法二 (声明式) |
| :--- | :--- | :--- |
| **核心实体** | 一个**可变的棋盘**状态 | 一系列**不可变的解**的集合 |
| **思维模型** | **时间旅行者**：模拟时间的演进和回溯 | **数学家**：定义解的结构和属性 |
| **状态管理** | **手动**、**有副作用**。程序员需时刻追踪状态。 | **自动**（通过函数参数传递）、**无副作用**。 |
| **复杂性来源** | 管理状态变化、确保正确回溯。 | 理解递归定义、确保基线条件正确。 |
| **代码风格** | “告诉计算机**如何做**” | “告诉计算机**我想要什么**” |

两种方法都能得到正确答案，但它们对程序员大脑的要求截然不同。命令式方法更符合我们的直觉，但需要我们承担管理复杂状态的重担。声明式方法初看起来可能有些抽象，但一旦理解，它就能将我们从繁琐的状态管理中解放出来，写出更清晰、更不容易出错的代码。