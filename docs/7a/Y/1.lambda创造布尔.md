好的，我们回到“创世”的第一幕。这是一个非常精彩的思维探险，它完美地展示了SICP“元语言抽象”的精髓——**通过定义行为来创造事物**。

我们的宇宙里只有两种“基本粒子”：

1.  **匿名函数 (`lambda`)**: 唯一的“物质”。
2.  **函数应用 (调用)**: 唯一的“相互作用力”。

我们的目标是，仅用这两种粒子，雕刻出“布尔值”和“数字”的形态。

-----

### **第一部分：创造“选择” —— 布尔值 (Booleans)**

逻辑学家们没有去想“布尔值是什么样的**数据**？”，而是问：“布尔值的**本质行为**是什么？”

布尔值的本质行为，就是**在两个选项中做出选择**。

#### **定义 TRUE 和 FALSE**

  * **`TRUE`** 的行为，应该是在“选项A”和“选项B”中，**永远选择前者**。
  * **`FALSE`** 的行为，应该是在“选项A”和“\_选项B”中，**永远选择后者**。

根据这个行为，我们可以把它们直接定义为函数：

```scheme
;; TRUE 是一个接收两个参数a和b，并永远返回第一个参数a的函数。
(define TRUE (lambda (a b) a))

;; FALSE 是一个接收两个参数a和b，并永远返回第二个参数b的函数。
(define FALSE (lambda (a b) b))
```

就这样，我们用函数“扮演”了布尔值。`TRUE`和`FALSE`不是数据`#t`和`#f`，而是两种不同的“选择行为”。

#### **创造 IF 条件判断**

如果我们有了代表“真”和“假”的行为了，那么`IF`语句又是什么呢？

一个`IF`语句，比如 `(if <condition> <then-clause> <else-clause>)`，它的作用不就是根据`<condition>`的真假，来选择执行哪个子句吗？

这恰好就是我们刚刚定义的`TRUE`和`FALSE`函数的行为！

所以，`IF`语句可以被定义为一个极其简单的函数，它仅仅是**把“真/假”这个选择函数，应用到两个选项上**：

```scheme
(define IF
  (lambda (condition then-clause else-clause)
    (condition then-clause else-clause)))
```

我们来测试一下这个微型宇宙：

  * `(IF TRUE "你好" "再见")`
    \-\> `(TRUE "你好" "再见")`
    \-\> 根据`TRUE`的定义，返回第一个参数，结果是 `"你好"`。
  * `(IF FALSE "你好" "再见")`
    \-\> `(FALSE "你好" "再见")`
    \-\> 根据`FALSE`的定义，返回第二个参数，结果是 `"再见"`。

成功了！我们仅用函数，就创造出了一套完整的逻辑判断系统。

