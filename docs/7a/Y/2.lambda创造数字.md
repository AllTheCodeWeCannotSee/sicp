### **第二部分：创造“重复” —— 数字 (Church Numerals)**

数字的创造过程更为精妙。逻辑学家们再次抛开数字的符号形式（1, 2, 3），去问它的**本质行为**是什么？

他们认为，一个数字 `n` 的本质，可以被理解为\*\*“将某个操作重复 n 次”\*\*这个行为。

#### **定义 0, 1, 2, 3...**

根据这个思想，每个数字都可以被定义为一个高阶函数。这个函数接收两样东西：一个“操作”`f`，和一个“初始值”`x`。

  * **`ZERO`**: 代表“将操作`f`重复0次”。这意味着什么都不做，直接返回那个“初始值”`x`。

    ```scheme
    (define ZERO (lambda (f) (lambda (x) x)))
    ```

  * **`ONE`**: 代表“将操作`f`重复1次”。这意味着对`x`执行一次`f`。

    ```scheme
    (define ONE (lambda (f) (lambda (x) (f x))))
    ```

  * **`TWO`**: 代表“将操作`f`重复2次”。这意味着对`x`执行两次`f`，即 `f(f(x))`。

    ```scheme
    (define TWO (lambda (f) (lambda (x) (f (f x)))))
    ```

  * **`THREE`**: 代表“将操作`f`重复3次”。即 `f(f(f(x)))`。

    ```scheme
    (define THREE (lambda (f) (lambda (x) (f (f (f x))))))
    ```

这些被称为**邱奇数**。我们再次成功地用纯函数“扮演”了自然数。每个数字，都是一个代表“重复特定次数”的“行为机器”。

#### **创造“加一”运算 (SUCCESSOR)**

有了数字，我们还需要运算。最基本的运算是“加一”（后继函数 `SUCCESSOR`）。

`SUCCESSOR` 的工作是：接收一个数字`n`（比如`TWO`），然后返回下一个数字`n+1`（即`THREE`）。

我们来思考`SUCCESSOR`该如何定义：

1.  它接收一个邱奇数`n`作为参数：`(lambda (n) ...)`
2.  它必须返回一个新的邱奇数。我们知道，所有邱奇数都是 `(lambda (f) (lambda (x) ...))` 这种结构。
3.  这个新数的函数体应该做什么？它应该比`n`多重复一次`f`。
4.  `n`重复`f`的结果是 `((n f) x)`。
5.  要再多重复一次，我们只需要把`f`应用到`n`的计算结果上就行了，即 `(f ((n f) x))`。

所以，`SUCCESSOR` 的定义就诞生了：

```scheme
(define SUCCESSOR
  (lambda (n)
    (lambda (f)
      (lambda (x)
        (f ((n f) x))))))
```

我们来测试一下 `(SUCCESSOR TWO)`:

1.  它返回一个新函数 `(lambda (f) (lambda (x) (f ((TWO f) x))))`。
2.  这个新函数就是`THREE`吗？我们来验证。
3.  `((TWO f) x)` 的结果是 `(f (f x))`。
4.  再把这个结果代入，得到 `(f (f (f x)))`。
5.  这正是`THREE`的定义！

成功了！我们用函数创造了数字，还创造了对数字的运算。