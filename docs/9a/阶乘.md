如果说 GCD 例子是用来**引入寄存器机器这个模型本身**，那么阶乘例子则是为了**展示这个模型如何处理更复杂的计算模式**。

具体来说，阶乘例子是在讲**如何处理“递归调用” (Recursive Call)，而不仅仅是 GCD 那样的“尾递归” (Tail Recursion)**。

这是一个巨大的飞跃，它直接引出了第五章乃至整个计算科学中最重要的概念之一：**栈 (The Stack)**。

---

### 1. 为什么需要一个新的例子？GCD 不够吗？

不够。我们回顾一下 GCD 算法：
`(gcd a b)` 的下一步是 `(gcd b (remainder a b))`。
计算出 `(remainder a b)` 之后，原来的 `a` 和 `b` 就**再也用不到了**。所以，我们可以直接用新值覆盖旧的寄存器，然后用一个 `goto` 跳转到开头，形成一个循环。这叫**尾递归**。

但阶乘算法不同：
`(factorial n)` 的计算依赖于 `(* n (factorial (- n 1)))`。
当我们要计算 `(factorial (- n 1))` 时，必须**记住**当前的 `n` 值，因为在子问题 `(factorial (- n 1))` 计算出结果之后，我们还需要用它来进行最后的乘法运算。

这个“**必须记住，稍后再用**”的需求，是 GCD 所没有的。它代表了一类更普遍、更复杂的计算过程。

### 2. 阶乘例子到底讲了什么？

阶乘例子通过引入**栈 (stack)** 和两个新指令 `save` 与 `restore`，完美地解决了上述“记忆”问题。

**它实际讲解了以下核心内容：**

1.  **引入“待处理的操作”概念 (Pending Operations)**
    * 阶乘的计算过程包含一系列“待进行的乘法”。计算 `5!` 就是 `5 * (4 * (3 * (2 * (1 * 1))))`。
    * 在计算内层的 `(factorial 4)` 时，外层的 `5 * ...` 就是一个“待处理的操作”。机器必须有办法暂存这些操作。

2.  **栈是“记忆”的物理实现**
    * 为了保存这些待处理的操作（或者说，保存将来恢复计算时所需要的上下文），SICP 引入了**栈**。
    * 栈是一个“后进先出”(LIFO) 的数据结构，完美匹配了递归调用的“层层深入，再层层返回”的模式。

3.  **引入 `save` 和 `restore` 指令**
    * **`save <register>`**：在进行“递归调用”（即跳转去计算子问题）之前，把一个寄存器的当前值压入栈中。在阶乘的例子里，我们需要 `save` 寄存器 `n` 和 `continue`（返回地址）。
    * **`restore <register>`**：在子问题计算完成，返回之后，从栈顶弹出一个值，恢复到指定的寄存器中。这样，机器就能“回忆起”在深入下一层之前它在做什么。

4.  **控制器如何模拟递归调用与返回**
    * **调用阶段 (Diving In)**：
        1.  用 `save n` 保存当前的 `n`。
        2.  用 `save continue` 保存返回点（比如 `fact-return` 标签）。
        3.  将 `n` 减 1。
        4.  用 `goto` 跳转到计算的开头 (`fact-loop`)，开始计算 `(factorial (- n 1))`。
    * **返回阶段 (Coming Back)**：
        1.  子问题的结果已经存放在 `val` 寄存器里。
        2.  用 `restore n` 恢复之前保存的 `n` 值。
        3.  用 `restore continue` 恢复返回地址，并跳转过去。
        4.  在返回点 `fact-return`，执行被挂起的乘法 `(* n val)`，并把结果存入 `val`。

### 总结

**如果说 GCD 例子展示了如何用 `goto` 将“尾递归”转换成“循环”，那么阶乘例子则展示了如何用“栈”来处理“普通递归”：**

* **GCD 例子**：教会了机器如何**循环 (looping)**。
* **阶乘例子**：教会了机器如何**调用和返回子过程 (subroutine call and return)**，这是构建模块化、可复用代码的基石。

这个“调用-返回”机制，是现代计算机中所有函数/方法调用的底层基础。通过阶乘这个例子，SICP 让你亲手在最简单的模型上实现了这个至关重要的机制，为后面理解更复杂的**求值器 (evaluator)** 铺平了道路。因为求值器本身就是一个巨大的、充满了各种互相调用的递归过程的程序。